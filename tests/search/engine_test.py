"""Tests for the search engine module.

These tests verify the core search functionality including tokenization,
scoring, rank fusion, and the SearchEngine class.
"""

import json
from unittest.mock import AsyncMock, MagicMock

import pytest

from lean_explore.search.engine import (
    _compute_ranks,
    _fuzzy_name_score,
    _is_autogenerated,
    _normalize_deps_log,
    _normalize_scores,
    _reciprocal_rank_fusion,
    _tokenize_raw,
    _tokenize_spaced,
    _weighted_score_fusion,
)


class TestAutogeneratedDetection:
    """Tests for auto-generated declaration detection."""

    def test_is_autogenerated_mk_constructor(self):
        """Test that .mk constructors are detected as auto-generated."""
        assert _is_autogenerated("Nat.mk") is True
        assert _is_autogenerated("MyStruct.mk") is True

    def test_is_autogenerated_normal_declarations(self):
        """Test that normal declarations are not flagged."""
        assert _is_autogenerated("Nat.add") is False
        assert _is_autogenerated("List.length") is False
        assert _is_autogenerated("mk") is False


class TestTokenization:
    """Tests for tokenization functions."""

    def test_tokenize_spaced_simple(self):
        """Test basic tokenization with dots and underscores."""
        assert _tokenize_spaced("Nat.add") == ["nat", "add"]
        assert _tokenize_spaced("my_function") == ["my", "function"]

    def test_tokenize_spaced_camel_case(self):
        """Test camelCase splitting."""
        assert _tokenize_spaced("myFunction") == ["my", "function"]
        assert _tokenize_spaced("MyStruct") == ["my", "struct"]

    def test_tokenize_spaced_empty(self):
        """Test empty input."""
        assert _tokenize_spaced("") == []

    def test_tokenize_raw_preserves_structure(self):
        """Test that raw tokenization preserves the full string."""
        assert _tokenize_raw("Nat.add") == ["nat.add"]
        assert _tokenize_raw("List.map") == ["list.map"]

    def test_tokenize_raw_empty(self):
        """Test empty input."""
        assert _tokenize_raw("") == []


class TestFuzzyNameScore:
    """Tests for fuzzy name matching."""

    def test_fuzzy_name_score_exact_match(self):
        """Test exact match returns high score."""
        score = _fuzzy_name_score("Nat.add", "Nat.add")
        assert score == 1.0

    def test_fuzzy_name_score_partial_match(self):
        """Test partial match returns reasonable score."""
        score = _fuzzy_name_score("add", "Nat.add")
        assert 0.0 < score < 1.0

    def test_fuzzy_name_score_no_match(self):
        """Test completely different strings."""
        score = _fuzzy_name_score("xyz", "Nat.add")
        assert score < 0.5


class TestScoreNormalization:
    """Tests for score normalization functions."""

    def test_normalize_scores_basic(self):
        """Test min-max normalization."""
        scores = [1.0, 2.0, 3.0, 4.0, 5.0]
        normalized = _normalize_scores(scores)
        assert normalized[0] == 0.0
        assert normalized[-1] == 1.0

    def test_normalize_scores_empty(self):
        """Test empty input."""
        assert _normalize_scores([]) == []

    def test_normalize_scores_same_values(self):
        """Test when all scores are the same."""
        scores = [5.0, 5.0, 5.0]
        normalized = _normalize_scores(scores)
        assert all(s == 1.0 for s in normalized)

    def test_normalize_scores_all_zeros(self):
        """Test when all scores are zero."""
        scores = [0.0, 0.0, 0.0]
        normalized = _normalize_scores(scores)
        assert all(s == 0.0 for s in normalized)

    def test_normalize_deps_log_basic(self):
        """Test log-scale normalization for dependency counts."""
        counts = [0, 1, 10, 100]
        normalized = _normalize_deps_log(counts)
        # Should be monotonically increasing
        for i in range(len(normalized) - 1):
            assert normalized[i] <= normalized[i + 1]
        # Max should be 1.0
        assert normalized[-1] == 1.0

    def test_normalize_deps_log_empty(self):
        """Test empty input."""
        assert _normalize_deps_log([]) == []

    def test_normalize_deps_log_all_zeros(self):
        """Test when all counts are zero."""
        counts = [0, 0, 0]
        normalized = _normalize_deps_log(counts)
        assert all(s == 0.0 for s in normalized)


class TestRankComputation:
    """Tests for rank computation."""

    def test_compute_ranks_basic(self):
        """Test basic rank computation."""
        scores = [0.5, 1.0, 0.3, 0.8]
        ranks = _compute_ranks(scores)
        # Highest score (1.0 at index 1) should have rank 1
        assert ranks[1] == 1
        # Second highest (0.8 at index 3) should have rank 2
        assert ranks[3] == 2

    def test_compute_ranks_with_zeros(self):
        """Test that zero scores get worst rank."""
        scores = [1.0, 0.0, 0.5]
        ranks = _compute_ranks(scores)
        # Zero score should get rank n+1
        assert ranks[1] == 4  # len(scores) + 1


class TestRankFusion:
    """Tests for rank fusion algorithms."""

    def test_reciprocal_rank_fusion_basic(self):
        """Test basic RRF computation."""
        rank_lists = [
            [1, 2, 3],  # Signal 1 ranks
            [3, 1, 2],  # Signal 2 ranks
        ]
        rrf_scores = _reciprocal_rank_fusion(rank_lists, k=0)
        # Item 0: 1/1 + 1/3 = 1.33
        # Item 1: 1/2 + 1/1 = 1.5
        # Item 2: 1/3 + 1/2 = 0.83
        assert len(rrf_scores) == 3
        # Item 1 should have highest RRF score
        assert rrf_scores[1] > rrf_scores[0]
        assert rrf_scores[1] > rrf_scores[2]

    def test_weighted_score_fusion_basic(self):
        """Test weighted score combination."""
        score_lists = [
            [0.0, 0.5, 1.0],  # Signal 1 scores
            [1.0, 0.5, 0.0],  # Signal 2 scores
        ]
        weights = [0.5, 0.5]
        combined = _weighted_score_fusion(score_lists, weights)
        # All items should get same score (0.5) due to symmetry
        assert len(combined) == 3
        assert abs(combined[0] - combined[2]) < 0.01

    def test_weighted_score_fusion_empty(self):
        """Test empty input."""
        assert _weighted_score_fusion([], []) == []


class TestSearchEngineInit:
    """Tests for SearchEngine initialization."""

    def test_search_engine_missing_files(self, temp_directory):
        """Test that SearchEngine raises error for missing files."""
        from lean_explore.search.engine import SearchEngine

        with pytest.raises(FileNotFoundError, match="Required file not found"):
            SearchEngine(
                faiss_index_path=temp_directory / "nonexistent.index",
                faiss_ids_map_path=temp_directory / "nonexistent.json",
            )


class TestSearchEngineSearch:
    """Integration tests for SearchEngine.search method."""

    @pytest.fixture
    def mock_search_engine(self, temp_directory, async_db_engine):
        """Create a SearchEngine with mocked FAISS and embedding client."""
        # Create mock FAISS files
        index_path = temp_directory / "informalization_faiss.index"
        ids_path = temp_directory / "informalization_faiss_ids_map.json"
        index_path.touch()
        with open(ids_path, "w") as f:
            json.dump([1, 2, 3], f)

        # Create mock embedding client
        mock_embedding_client = MagicMock()
        mock_embedding_response = MagicMock()
        mock_embedding_response.embeddings = [[0.1] * 1024]
        mock_embedding_client.embed = AsyncMock(return_value=mock_embedding_response)

        # Create mock reranker client
        mock_reranker_client = MagicMock()
        mock_reranker_response = MagicMock()
        mock_reranker_response.scores = [0.9, 0.7, 0.5]
        mock_reranker_client.rerank = AsyncMock(return_value=mock_reranker_response)

        from lean_explore.search.engine import SearchEngine

        engine = SearchEngine(
            db_url="sqlite+aiosqlite:///:memory:",
            embedding_client=mock_embedding_client,
            reranker_client=mock_reranker_client,
            faiss_index_path=index_path,
            faiss_ids_map_path=ids_path,
        )

        return engine

    @pytest.mark.integration
    async def test_search_empty_query(self, mock_search_engine):
        """Test that empty query returns empty results."""
        results = await mock_search_engine.search("")
        assert results == []

        results = await mock_search_engine.search("   ")
        assert results == []
